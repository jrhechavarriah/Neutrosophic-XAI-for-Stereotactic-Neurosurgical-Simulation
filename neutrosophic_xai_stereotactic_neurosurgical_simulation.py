# -*- coding: utf-8 -*-
"""neutrosophic_xai_stereotactic_neurosurgical_simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xwRtYKbi7syiBuEoOTxUP7xiFvhsbhyi
"""

try:
    import scikit_posthocs as sp
except ImportError:
    !pip install scikit-posthocs
    import scikit_posthocs as sp

import os
import shutil

folder = "/content/neutrosophic_outputs"

if os.path.exists(folder):
    for item in os.listdir(folder):
        item_path = os.path.join(folder, item)
        try:
            if os.path.isfile(item_path) or os.path.islink(item_path):
                os.remove(item_path)
            elif os.path.isdir(item_path):
                shutil.rmtree(item_path)
            print(f"Eliminado: {item_path}")
        except Exception as e:
            print(f"No se pudo eliminar {item_path}: {e}")
else:
    print("La carpeta no existe.")

"""
neutrosophic_xai_frontiers.py

Reproducible pipeline for generating synthetic data, figures, and tables
for the Neutrosophic XAI framework manuscript (Frontiers style).

This script:
  - defines neutrosophic membership functions T(d,s), I(d,s), F(d,s)
  - simulates synthetic trainee data for three groups (Expert, Indeterminate, Novice)
  - computes the competence score S(d,s)
  - generates Figures 1–7 as PNG files (Frontiers legends order)
  - generates Tables 1–2 as CSV + Markdown text files

Usage
-----
python neutrosophic_xai_frontiers.py

Dependencies
------------
numpy
pandas
matplotlib
scipy
scikit-posthocs

Install with:
    pip install numpy pandas matplotlib scipy scikit-posthocs
"""

import os
from typing import Tuple

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, FancyArrowPatch
from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
from matplotlib import cm
from scipy import stats
import scikit_posthocs as sp

from matplotlib.colors import ListedColormap

# ---------------------------------------------------------------------
# Global configuration
# ---------------------------------------------------------------------

OUTDIR = "neutrosophic_outputs"
RNG_SEED = 42

os.makedirs(OUTDIR, exist_ok=True)
np.random.seed(RNG_SEED)


# ---------------------------------------------------------------------
# Neutrosophic model
# ---------------------------------------------------------------------

# Distance and instability scales (mm and arbitrary units, respectively)
D_MAX = 3.0      # upper bound for "good" spatial deviation
D_CRIT = 4.0     # clinically unsafe deviation
S_MAX = 0.30     # maximum motor instability considered
D_MID = 1.5      # center of mid-risk band
D_RANGE = 1.5    # width of mid-risk band (approx 1.5–2.0 mm)


def T_func(d: np.ndarray, s: np.ndarray) -> np.ndarray:
    """
    Truth membership function T(d, s).

    High when spatial deviation and instability are both low.
    """
    d = np.asarray(d)
    s = np.asarray(s)
    term_d = np.clip(1.0 - d / D_MAX, 0.0, 1.0)
    term_s = np.clip(1.0 - s / S_MAX, 0.0, 1.0)
    return term_d * term_s


def F_func(d: np.ndarray, s: np.ndarray) -> np.ndarray:
    """
    Falsity membership function F(d, s).

    Increases as distance approaches/ exceeds the critical value
    and as instability grows.
    """
    d = np.asarray(d)
    s = np.asarray(s)
    fd = np.clip(d / D_CRIT, 0.0, 1.0)
    fs = np.clip(s / S_MAX, 0.0, 1.0)
    return np.maximum(fd, fs)

def I_func(d: np.ndarray, s: np.ndarray) -> np.ndarray:
    """
    Indeterminacy membership function I(d, s).

    Peaks for intermediate distances (≈1.5–2.0 mm) and
    moderate-to-high instability.
    """
    d = np.asarray(d)
    s = np.asarray(s)

    tri = 1.0 - np.abs((d - D_MID) / D_RANGE)
    tri = np.clip(tri, 0.0, 1.0)

    s_scaled = np.clip(s / S_MAX, 0.0, 1.0)

    I = tri * s_scaled

    return np.clip(I, 0.0, 1.0)

def S_score(T: np.ndarray, I: np.ndarray, F: np.ndarray) -> np.ndarray:
    """
    Neutrosophic competence score.

    Higher values reflect expert-like performance; lower values
    reflect unsafe behavior, with indeterminacy penalized.
    """
    return (2.0 + T - I - F) / 3.0


# ---------------------------------------------------------------------
# Synthetic dataset
# ---------------------------------------------------------------------

def simulate_group(
    label: str,
    n: int,
    d_mean: float,
    d_std: float,
    s_mean: float,
    s_std: float,
) -> pd.DataFrame:
    """
    Generate synthetic (d, s) samples for a group and compute
    T, I, F, and S scores.
    """
    d = np.abs(np.random.normal(d_mean, d_std, n))
    s = np.abs(np.random.normal(s_mean, s_std, n))

    T = T_func(d, s)
    F = F_func(d, s)
    I = I_func(d, s)
    S = S_score(T, I, F)

    return pd.DataFrame(
        {
            "group": label,
            "d_mm": d,
            "s_instability": s,
            "T": T,
            "I": I,
            "F": F,
            "S": S,
        }
    )


def build_dataset(n_each: int = 20) -> pd.DataFrame:
    """
    Build full dataset with Expert, Indeterminate, and Novice cohorts.
    """
    df_expert = simulate_group(
        "Expert",
        n_each,
        d_mean=0.5,
        d_std=0.20,
        s_mean=0.05,
        s_std=0.01,
    )

    df_indet = simulate_group(
        "Indeterminate",
        n_each,
        d_mean=2.0,
        d_std=0.30,
        s_mean=0.15,
        s_std=0.05,
    )

    df_novice = simulate_group(
        "Novice",
        n_each,
        d_mean=4.0,
        d_std=0.50,
        s_mean=0.25,
        s_std=0.07,
    )

    data = pd.concat([df_expert, df_indet, df_novice], ignore_index=True)
    data.to_csv(os.path.join(OUTDIR, "neutrosophic_dataset.csv"), index=False)
    return data


# ---------------------------------------------------------------------
# Figures
# ---------------------------------------------------------------------
def figure1_pipeline():
    """
    Figure 1. Conceptual system architecture for the Neutrosophic XAI framework.
    """
    fig, ax = plt.subplots(figsize=(3.8, 3.8))
    ax.axis("off")

    # ------------------------------------------------------------------
    # Helpers
    # ------------------------------------------------------------------
    def add_box(text, center, width=0.70, height=0.16):
        """
        Draw a rounded box centered at `center` (in axis-relative coords).
        """
        cx, cy = center
        x = cx - width / 2.0
        y = cy - height / 2.0

        box = FancyBboxPatch(
            (x, y),
            width,
            height,
            boxstyle="round,pad=0.02",
            linewidth=1.5,
            edgecolor="black",
            facecolor="white",
        )
        ax.add_patch(box)
        ax.text(
            cx,
            cy,
            text,
            ha="center",
            va="center",
            fontsize=9,
        )

    def add_arrow(start, end):
        """
        Arrow from start to end (in axis-relative coords).
        """
        arrow = FancyArrowPatch(
            posA=start,
            posB=end,
            arrowstyle="Simple,head_width=6,head_length=8",
            linewidth=1.2,
            color="black",
        )
        ax.add_patch(arrow)

    sim_center   = (0.5, 0.78)
    data_center  = (0.5, 0.50)
    nxai_center  = (0.5, 0.22)

    add_box(
        "Immersive Simulation Layer\n"
        "(Unreal Engine 5)\n"
        "Spatial data, trajectories,\n"
        "micromovements",
        sim_center,
    )

    add_box(
        "Data Acquisition Layer\n"
        "Spatial Accuracy (d)\n"
        "Motor Stability (s)",
        data_center,
    )

    add_box(
        "Neutrosophic XAI Layer\n"
        "T(d, s), I(d, s), F(d, s)\n"
        "Competence Score S(d, s)",
        nxai_center,
    )

    add_arrow((0.5, 0.68), (0.5, 0.60))
    add_arrow((0.5, 0.40), (0.5, 0.32))

    ax.set_xlim(0.1, 0.9)
    ax.set_ylim(0.1, 0.9)

    ax.set_title(
        "Figure 1. Conceptual architecture - Neutrosophic XAI",
        fontsize=10,
        pad=10,
    )

    plt.tight_layout()
    fig.savefig(os.path.join(OUTDIR, "figure1_pipeline.png"), dpi=300)
    plt.show()
    plt.close(fig)

def figure2_boxplot(data: pd.DataFrame):
    """
    Figure 2. Distribution of Neutrosophic scores across groups.
    """
    fig, ax = plt.subplots(figsize=(5, 4))

    groups = ["Expert", "Indeterminate", "Novice"]
    score_data = [data[data["group"] == g]["S"].values for g in groups]

    bp = ax.boxplot(
        score_data,
        labels=groups,
        patch_artist=True,
        showmeans=False,
    )

    for patch in bp["boxes"]:
        patch.set_facecolor("white")

    for i, g in enumerate(groups, start=1):
        subset = data[data["group"] == g]["S"].values
        x = np.random.normal(i, 0.05, size=len(subset))
        ax.scatter(
            x,
            subset,
            s=35,
            edgecolors="black",
            facecolors="tab:blue",
            alpha=0.8,
        )

    ax.set_ylabel("Neutrosophic competence score S(d, s)")
    ax.set_title("Figure 2. Distribution of Neutrosophic scores")

    ax.set_ylim(0, 1.0)
    ax.grid(axis="y", alpha=0.3)

    plt.tight_layout()
    fig.savefig(os.path.join(OUTDIR, "figure2_boxplot_scores.png"), dpi=300)
    plt.show()
    plt.close(fig)

def figure3_decision_boundaries(data: pd.DataFrame):
    """
    Figure 3. Comparison of classical and Neutrosophic decision boundaries.
    """
    d_vals = np.linspace(0.0, 4.0, 200)
    s_vals = np.linspace(0.0, S_MAX, 200)
    D, Sg, S_val = _grid_S(d_vals, s_vals)

    # Classical threshold: d < 2 mm is "pass"
    classical_pass = (D < 2.0).astype(float)

    # Neutrosophic discrete classes
    expert_zone = S_val > 0.7
    indet_zone = (S_val >= 0.4) & (S_val <= 0.7)
    novice_zone = S_val < 0.4

    class_map = np.full(S_val.shape, np.nan)
    class_map[novice_zone] = 0
    class_map[indet_zone] = 1
    class_map[expert_zone] = 2

    group_colors = {
        "Expert": "green",
        "Indeterminate": "orange",
        "Novice": "red",
    }

    zone_cmap = ListedColormap([
        "#fdae61",  # Novice / unsafe
        "#abd9e9",  # Indeterminate
        "#1a9850",  # Expert / safe
    ])

    fig, axes = plt.subplots(1, 2, figsize=(11, 4.5), sharey=True)

    # --------------------------------------------------
    # Panel A: Classical threshold
    # --------------------------------------------------
    ax = axes[0]
    ax.imshow(
        classical_pass,
        origin="lower",
        aspect="auto",
        extent=[d_vals.min(), d_vals.max(), s_vals.min(), s_vals.max()],
        cmap="Greys",
        alpha=0.5,
    )

    ax.axvline(2.0, color="black", linestyle="--", linewidth=1)

    for group, color in group_colors.items():
        subset = data[data["group"] == group]
        ax.scatter(
            subset["d_mm"],
            subset["s_instability"],
            label=group,
            s=90,
            edgecolors="black",
            facecolors=color,
            alpha=0.9,
        )

    ax.set_title("(A) Classical threshold d ≤ 2 mm", fontsize=11)
    ax.set_xlabel("Spatial deviation d (mm)", fontsize=10)
    ax.set_ylabel("Instability s", fontsize=10)
    ax.grid(alpha=0.3)

    # --------------------------------------------------
    # Panel B: Neutrosophic model
    # --------------------------------------------------
    ax2 = axes[1]
    im = ax2.imshow(
        class_map,
        origin="lower",
        aspect="auto",
        extent=[d_vals.min(), d_vals.max(), s_vals.min(), s_vals.max()],
        cmap=zone_cmap,
        alpha=0.7,
    )

    for group, color in group_colors.items():
        subset = data[data["group"] == group]
        ax2.scatter(
            subset["d_mm"],
            subset["s_instability"],
            s=90,
            edgecolors="black",
            facecolors=color,
            alpha=0.9,
        )

    ax2.set_title("(B) Neutrosophic XAI model", fontsize=11)
    ax2.set_xlabel("Spatial deviation d (mm)", fontsize=10)
    ax2.grid(alpha=0.3)

    handles = []
    for group, color in group_colors.items():
        h = ax2.scatter([], [], s=90, edgecolors="black", facecolors=color, alpha=0.9, label=group)
        handles.append(h)
    fig.legend(
        handles,
        list(group_colors.keys()),
        loc="upper center",
        ncol=3,
        frameon=False,
        fontsize=9,
        title="Group",
    )

    plt.tight_layout(rect=[0, 0, 1, 0.92])
    fig.savefig(os.path.join(OUTDIR, "figure3_decision_boundaries.png"), dpi=300)
    plt.show()
    plt.close(fig)


def figure4_scatter(data: pd.DataFrame):
    """
    Figure 4. Scatter plot of synthetic trainee performance mapped to S(d, s)
    with group legend + continuous colormap (RdYlGn).
    """
    fig, ax = plt.subplots(figsize=(9, 4))

    group_colors = {
        "Expert": "green",
        "Indeterminate": "orange",
        "Novice": "red",
    }

    scatter = ax.scatter(
        data["d_mm"],
        data["S"],
        c=data["S"],
        cmap="RdYlGn",
        s=110,
        edgecolors="black",
        alpha=0.9,
    )

    ax.axhline(0.7, color='grey', linestyle=':', linewidth=1)

    for group, color in group_colors.items():
        ax.scatter([], [], color=color, edgecolors='black', s=90, label=group)

    ax.legend(title="Group", frameon=False, fontsize=10)

    ax.set_xlabel("Spatial Deviation d (mm)", fontsize=11)
    ax.set_ylabel("Neutrosophic Competence Score S(d, s)", fontsize=11)
    ax.set_title("Figure 4. Synthetic Trainee Performance", fontsize=13)

    cbar = fig.colorbar(scatter, ax=ax)
    cbar.set_label("Competence Score S(d, s)", fontsize=10)

    ax.grid(alpha=0.3)
    plt.tight_layout()
    fig.savefig(os.path.join(OUTDIR, "figure4_scatter_scores.png"), dpi=300)
    plt.show()

def figure5_membership():
    """
    Figure 5. Neutrosophic membership functions across three instability levels,
    with a unified top legend in linear format.
    """
    d_vals = np.linspace(0.0, 4.0, 200)
    s_levels = [0.05, 0.15, 0.25]
    labels = ["Low instability (s = 0.05)", "Moderate (s = 0.15)", "High (s = 0.25)"]

    fig, axes = plt.subplots(1, 3, figsize=(11, 3.5), sharey=True)

    color_T = "#1a9850"   # green
    color_I = "#fdae61"   # orange
    color_F = "#d73027"   # red

    handles = None

    for ax, s, lab in zip(axes, s_levels, labels):

        T = T_func(d_vals, s)
        I = I_func(d_vals, s)
        F = F_func(d_vals, s)

        l1, = ax.plot(d_vals, T, label="Truth T(d,s)", color=color_T, linewidth=2)
        l2, = ax.plot(d_vals, I, label="Indeterminacy I(d,s)", color=color_I, linewidth=2)
        l3, = ax.plot(d_vals, F, label="Falsity F(d,s)", color=color_F, linewidth=2)

        if handles is None:
            handles = [l1, l2, l3]

        ax.set_xlabel("Distance d (mm)", fontsize=10)
        ax.set_title(lab, fontsize=10)
        ax.set_ylim(0, 1.05)
        ax.grid(alpha=0.3)

    axes[0].set_ylabel("Membership value", fontsize=10)

    fig.suptitle("Figure 5. Neutrosophic membership functions", fontsize=12)

    fig.legend(
        handles,
        ["Truth T(d,s)", "Indeterminacy I(d,s)", "Falsity F(d,s)"],
        loc="upper center",
        ncol=3,
        frameon=False,
        fontsize=10,
        bbox_to_anchor=(0.5, 0.9)
    )

    plt.tight_layout(rect=[0, 0, 1, 0.88])
    fig.savefig(os.path.join(OUTDIR, "figure5_membership_functions.png"), dpi=300)
    plt.show()

def _grid_S(d_vals: np.ndarray, s_vals: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    D, Sg = np.meshgrid(d_vals, s_vals)
    T = T_func(D, Sg)
    I = I_func(D, Sg)
    F = F_func(D, Sg)
    S_val = S_score(T, I, F)
    return D, Sg, S_val

def figure6_combined():
    """
    Figure 6. Neutrosophic competence surface (left) and heatmap (right),
    displayed side by side in a unified Frontiers-style figure.
    """

    d_vals_surface = np.linspace(0.0, 4.0, 60)
    s_vals_surface = np.linspace(0.0, S_MAX, 50)
    D_surf, Sg_surf, S_val_surf = _grid_S(d_vals_surface, s_vals_surface)

    d_vals_hm = np.linspace(0.0, 4.0, 120)
    s_vals_hm = np.linspace(0.0, S_MAX, 90)
    D_hm, Sg_hm, S_val_hm = _grid_S(d_vals_hm, s_vals_hm)

    fig = plt.figure(figsize=(12, 5))

    # ============================================================
    # Panel A: 3D Surface Plot
    # ============================================================
    ax1 = fig.add_subplot(1, 2, 1, projection="3d")

    surf = ax1.plot_surface(
        D_surf, Sg_surf, S_val_surf,
        cmap=cm.viridis,
        linewidth=0,
        antialiased=True,
        alpha=0.92,
    )

    ax1.set_xlabel("Distance d (mm)", fontsize=10)
    ax1.set_ylabel("Instability s", fontsize=10)
    ax1.set_zlabel("S(d, s)", fontsize=10)
    ax1.set_title("(A) 3D competence surface S(d, s)", fontsize=11)
    ax1.view_init(elev=35, azim=-50)

    # ============================================================
    # Panel B: Heatmap
    # ============================================================
    ax2 = fig.add_subplot(1, 2, 2)

    hm = ax2.imshow(
        S_val_hm,
        origin="lower",
        aspect="auto",
        cmap="viridis",
        extent=[d_vals_hm.min(), d_vals_hm.max(), s_vals_hm.min(), s_vals_hm.max()],
    )

    cs = ax2.contour(
        D_hm,
        Sg_hm,
        S_val_hm,
        levels=[0.3, 0.4, 0.5, 0.7, 0.9],
        colors="white",
        linewidths=0.8,
    )
    ax2.clabel(cs, inline=True, fontsize=7, fmt="%.1f")

    ax2.set_xlabel("Distance d (mm)", fontsize=10)
    ax2.set_ylabel("Instability s", fontsize=10)
    ax2.set_title("(B) Heatmap of S(d, s)", fontsize=11)

    cbar = fig.colorbar(hm, ax=ax2, shrink=0.8)
    cbar.set_label("S(d, s)", fontsize=10)

    plt.tight_layout()
    fig.savefig(os.path.join(OUTDIR, "figure6_combined.png"), dpi=330)
    plt.show()

# ---------------------------------------------------------------------
# Tables (Frontiers style content)
# ---------------------------------------------------------------------

def build_table1(data: pd.DataFrame) -> pd.DataFrame:
    """
    Table 1. Descriptive statistics of S(d, s) across groups.
    """
    rows = []
    for group, df_g in data.groupby("group"):
        n = df_g.shape[0]
        mean = df_g["S"].mean()
        std = df_g["S"].std(ddof=1)
        median = df_g["S"].median()
        min_val = df_g["S"].min()
        max_val = df_g["S"].max()

        rows.append(
            {
                "Group": group,
                "n": n,
                "Mean ± SD": f"{mean:.3f} ± {std:.3f}",
                "Median": f"{median:.3f}",
                "Min–Max": f"{min_val:.3f}–{max_val:.3f}",
            }
        )

    table1 = pd.DataFrame(rows)
    table1 = table1.set_index("Group")

    table1.to_csv(os.path.join(OUTDIR, "table1_descriptives.csv"))

    # Markdown representation (Frontiers-style minimal table)
    md_lines = ["Table 1. Descriptive statistics of Neutrosophic competence scores across simulated trainee groups.\n"]
    md_lines.append("| Group | n | Mean ± SD | Median | Min–Max |")
    md_lines.append("|:------|--:|:----------|:------:|:-------|")

    for idx, row in table1.reset_index().iterrows():
        md_lines.append(
            f"| {row['Group']} | {int(row['n'])} | {row['Mean ± SD']} | {row['Median']} | {row['Min–Max']} |"
        )

    legend = (
        "Legend: Table 1 presents descriptive statistics for the Neutrosophic "
        "competence score S(d, s) for all three simulated groups. Expert participants "
        "show high and narrow distributions, Indeterminate performers show intermediate "
        "and broader values, and Novices show consistently low scores."
    )

    md_lines.append("")
    md_lines.append(legend)

    with open(os.path.join(OUTDIR, "table1_descriptives.md"), "w") as f:
        f.write("\n".join(md_lines))

    return table1


def build_table2(data: pd.DataFrame) -> dict:
    """
    Table 2. Statistical analysis: Shapiro–Wilk, Kruskal–Wallis, and Dunn post-hoc.
    """
    # Normality tests
    normality_rows = []
    for group, df_g in data.groupby("group"):
        W, p = stats.shapiro(df_g["S"])
        normality_rows.append(
            {
                "Group": group,
                "W": W,
                "p-value": p,
                "Normality": "Yes" if p > 0.05 else "No",
            }
        )
    normality_df = pd.DataFrame(normality_rows)

    # Kruskal–Wallis omnibus
    groups = [df_g["S"].values for _, df_g in data.groupby("group")]
    H, p_kw = stats.kruskal(*groups)
    kw_df = pd.DataFrame(
        {
            "Test": ["Kruskal–Wallis"],
            "H-value": [H],
            "p-value": [p_kw],
            "Interpretation": ["Groups differ significantly" if p_kw < 0.05 else "No significant differences"],
        }
    )

    # Dunn post-hoc with Bonferroni correction
    posthoc = sp.posthoc_dunn(
        data,
        val_col="S",
        group_col="group",
        p_adjust="bonferroni",
    )

    # Build long form summary for manuscript
    comparisons = []
    groups_labels = list(data["group"].unique())
    for i, g1 in enumerate(groups_labels):
        for j, g2 in enumerate(groups_labels):
            if j <= i:
                continue
            p_val = posthoc.loc[g1, g2]
            comparisons.append(
                {
                    "Comparison": f"{g1} vs {g2}",
                    "p-value": p_val,
                    "Interpretation": "Significant" if p_val < 0.05 else "Not significant",
                }
            )
    posthoc_long = pd.DataFrame(comparisons)

    # Save all components
    normality_df.to_csv(os.path.join(OUTDIR, "table2_normality.csv"), index=False)
    kw_df.to_csv(os.path.join(OUTDIR, "table2_kruskal.csv"), index=False)
    posthoc_long.to_csv(os.path.join(OUTDIR, "table2_dunn_long.csv"), index=False)
    posthoc.to_csv(os.path.join(OUTDIR, "table2_dunn_matrix.csv"))

    # Markdown block with legend (Frontiers style)
    md_lines = ["Table 2. Statistical analysis of group differences (normality tests, omnibus test, and post hoc comparisons).\n"]

    md_lines.append("**Normality testing (Shapiro–Wilk)**")
    md_lines.append("")
    md_lines.append("| Group | W | p-value | Normality |")
    md_lines.append("|:------|---:|--------:|:----------|")
    for _, row in normality_df.iterrows():
        md_lines.append(
            f"| {row['Group']} | {row['W']:.4f} | {row['p-value']:.4f} | {row['Normality']} |"
        )

    md_lines.append("\n**Omnibus test (Kruskal–Wallis)**\n")
    md_lines.append("| Test | H-value | p-value | Interpretation |")
    md_lines.append("|:-----|--------:|--------:|:---------------|")
    md_lines.append(
        f"| Kruskal–Wallis | {H:.4f} | {p_kw:.4g} | {kw_df['Interpretation'].iloc[0]} |"
    )

    md_lines.append("\n**Post hoc significance (Dunn test, Bonferroni-corrected p-values)**\n")
    md_lines.append("| Comparison | p-value | Interpretation |")
    md_lines.append("|:-----------|--------:|:--------------|")
    for _, row in posthoc_long.iterrows():
        md_lines.append(
            f"| {row['Comparison']} | {row['p-value']:.6f} | {row['Interpretation']} |"
        )

    legend = (
        "Legend: Table 2 summarizes the inferential statistical analysis. "
    )
    md_lines.append("")
    md_lines.append(legend)

    with open(os.path.join(OUTDIR, "table2_statistics.md"), "w") as f:
        f.write("\n".join(md_lines))

    return {
        "normality": normality_df,
        "kruskal": kw_df,
        "dunn_matrix": posthoc,
        "dunn_long": posthoc_long,
    }

# ---------------------------------------------------------------------
# Orchestrator
# ---------------------------------------------------------------------

def main():
    # 1. Synthetic dataset
    data = build_dataset(n_each=20)

    # 2. Figures (in the same logical order as Figure Legends)
    figure1_pipeline()
    figure2_boxplot(data)
    figure3_decision_boundaries(data)
    figure4_scatter(data)
    figure5_membership()
    figure6_combined() # surface-heatmap

    # 3. Tables
    table1 = build_table1(data)
    tables2 = build_table2(data)

    # 4. Print short console summary (useful for Zenodo README)
    print("=== Neutrosophic XAI synthetic dataset summary ===")
    print(table1)
    print("\nKruskal–Wallis test:")
    print(tables2["kruskal"])
    print("\nDunn post-hoc (Bonferroni-corrected) p-values matrix:")
    print(tables2["dunn_matrix"])


if __name__ == "__main__":
    main()